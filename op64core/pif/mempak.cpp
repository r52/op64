#include "mempak.h"

#include <core/bus.h>
#include <rom/rom.h>
#include <ui/configstore.h>


MemPak::MemPak()
{

}


MemPak::~MemPak()
{
    if (_mempakfile.is_open())
    {
        _mempakfile.close();
    }
}

void MemPak::read(int control, int address, uint8_t* buf)
{
    if (address == 0x8001) {
        memset(buf, 0, 0x20);
        buf[0x20] = calculateCRC(buf);
        return;
    }
    address &= 0xFFE0;

    if (address <= 0x7FE0) {
        if (!_mempakfile.is_open()) {
            loadMempak();
        }
        memcpy(buf, &_mempaks[control][address], 0x20);
    }
    else {
        memset(buf, 0, 0x20);
        /* Rumble pack area */
    }

    buf[0x20] = calculateCRC(buf);
}

void MemPak::write(int control, int address, uint8_t* buf)
{
    if (address == 0x8001)
    {
        buf[0x20] = calculateCRC(buf);
        return;
    }

    address &= 0xFFE0;
    if (address <= 0x7FE0) {
        if (!_mempakfile.is_open()) {
            loadMempak();
        }
        memcpy(&_mempaks[control][address], buf, 0x20);

        _mempakfile.seekp(control * 0x8000, std::ios::beg);
        _mempakfile.write((char*)&_mempaks[control][0], 0x8000);
    }
    else {
        /* Rumble pack area */
    }
    buf[0x20] = calculateCRC(buf);
}

void MemPak::loadMempak(void)
{
    uint8_t init[] = {
        0x81, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0C, 0x0D, 0x0E, 0x0F,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
        0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0x1A, 0x5F, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0x66, 0x25, 0x99, 0xCD,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0x1A, 0x5F, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0x66, 0x25, 0x99, 0xCD,
        0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0x1A, 0x5F, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0x66, 0x25, 0x99, 0xCD,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0x1A, 0x5F, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0x66, 0x25, 0x99, 0xCD,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x71, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03,
    };

    for (int32_t i = 0; i < 4; i++) {
        for(int32_t j = 0; j < 0x8000; j += 2) {
            _mempaks[i][j] = 0;
            _mempaks[i][j + 1] = 0x03;
        }
        memcpy(&_mempaks[i], init, sizeof(init));
    }

    using namespace boost::filesystem;

    path mpakpath(ConfigStore::getInstance().getString(CFG_SECTION_CORE, "SavePath") + Bus::rom->getRomFilenameNoExtension() + ".mpk");

    if (!exists(mpakpath.parent_path()))
    {
        create_directories(mpakpath.parent_path());
    }

    if (!exists(mpakpath))
    {
        _mempakfile.open(mpakpath, std::ios::out);
        _mempakfile.seekp(0, std::ios::beg);
        _mempakfile.write((char*)_mempaks, sizeof(_mempaks));
        _mempakfile.close();
    }

    _mempakfile.open(mpakpath, std::ios::in | std::ios::out | std::ios::binary);
    _mempakfile.seekg(0, std::ios::beg);
    _mempakfile.seekp(0, std::ios::beg);
}

uint8_t MemPak::calculateCRC(uint8_t* src)
{
    uint8_t CRC = 0;
    for (int32_t i = 0; i <= 0x20; i++)
    {
        int mask;
        for (mask = 0x80; mask >= 1; mask >>= 1)
        {
            int xor_tap = (CRC & 0x80) ? 0x85 : 0x00;
            CRC <<= 1;
            if (i != 0x20 && (src[i] & mask))
            {
                CRC |= 1;
            }
            CRC ^= xor_tap;
        }
    }
    return CRC;
}
